!function(n,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define("Ayame",[],e):"object"==typeof exports?exports.Ayame=e():n.Ayame=e()}(window,function(){return function(n){var e={};function t(s){if(e[s])return e[s].exports;var i=e[s]={i:s,l:!1,exports:{}};return n[s].call(i.exports,i,i.exports,t),i.l=!0,i.exports}return t.m=n,t.c=e,t.d=function(n,e,s){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:s})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var s=Object.create(null);if(t.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var i in n)t.d(s,i,function(e){return n[e]}.bind(null,i));return s},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s="./ayame.js")}({"./ayame.js":
/*!******************!*\
  !*** ./ayame.js ***!
  \******************/
/*! exports provided: connection, version */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "connection", function() { return connection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });\n/* harmony import */ var _connection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./connection */ "./connection/index.js");\n\nconst defaultOptions = {\n  audio: true,\n  video: true,\n  iceServers: [{\n    urls: \'stun:stun.l.google.com:19302\'\n  }]\n};\nfunction connection(signalingUrl, roomId, options = defaultOptions) {\n  return new _connection__WEBPACK_IMPORTED_MODULE_0__["default"](signalingUrl, roomId, options);\n}\nfunction version() {\n  return "0.0.1-rc2";\n}\n\n//# sourceURL=webpack://Ayame/./ayame.js?')},"./connection/index.js":
/*!*****************************!*\
  !*** ./connection/index.js ***!
  \*****************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ \"./utils.js\");\n\n\nclass Connection {\n  constructor(signalingUrl, roomId, options) {\n    this.roomId = roomId;\n    this.signalingUrl = signalingUrl;\n    this.options = options;\n\n    if (options.clientId) {\n      this.clientId = options.clientId;\n    } else {\n      this.clientId = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"randomString\"])(17);\n    }\n\n    this.stream = null;\n    this._pc = null;\n    this.authnMetadata = null;\n    this._callbacks = {\n      connect: () => {},\n      disconnect: () => {},\n      addstream: () => {},\n      removestream: () => {}\n    };\n  }\n\n  on(kind, callback) {\n    if (kind in this._callbacks) {\n      this._callbacks[kind] = callback;\n    }\n  }\n\n  async connect(stream, authnMetadata = null) {\n    this.stream = stream;\n    this._hasReceivedSdp = false;\n    this._candidates = [];\n    this.authnMetadata = authnMetadata;\n\n    this._signaling();\n\n    return stream;\n  }\n\n  disconnect() {\n    this.remoteStreamId = null;\n\n    if (this.stream) {\n      this.stream.getTracks().forEach(t => {\n        t.stop();\n      });\n    }\n\n    this.stream = null;\n\n    this._ws.onclose = () => {};\n\n    this._ws.close();\n\n    if (this._pc && this._pc.signalingState !== 'closed') {\n      this._pc.close();\n    }\n\n    this._pc = null;\n  }\n\n  _signaling() {\n    this._ws = new WebSocket(this.signalingUrl);\n\n    this._ws.onopen = () => {\n      const registerMessage = {\n        type: 'register',\n        roomId: this.roomId,\n        clientId: this.clientId,\n        authnMetadata: undefined\n      };\n\n      if (this.authnMetadata !== null) {\n        registerMessage.authnMetadata = this.authnMetadata;\n      }\n\n      this._sendWs(registerMessage);\n    };\n\n    this._ws.onclose = async event => {\n      this.disconnect();\n\n      this._callbacks.disconnect(event);\n    };\n\n    this._ws.onmessage = async event => {\n      try {\n        if (typeof event.data !== 'string') {\n          return;\n        }\n\n        const message = JSON.parse(event.data);\n\n        if (message.type === 'ping') {\n          this._sendWs({\n            type: 'pong'\n          });\n        } else if (message.type === 'close') {\n          this._callbacks.close(event);\n        } else if (message.type === 'accept') {\n          if (!this._pc) this._pc = this._createPeerConnection();\n\n          this._callbacks.connect({\n            authzMetadata: message.authzMetadata\n          });\n\n          this._ws.onclose = closeEvent => {\n            this.disconnect();\n\n            this._callbacks.disconnect({\n              reason: 'WS-CLOSED',\n              event: closeEvent\n            });\n          };\n        } else if (message.type === 'reject') {\n          this.disconnect();\n\n          this._callbacks.disconnect({\n            reason: 'REJECTED'\n          });\n        } else if (message.type === 'offer') {\n          const offer = new window.RTCSessionDescription(message);\n\n          this._setOffer(offer);\n        } else if (message.type === 'answer') {\n          const answer = new window.RTCSessionDescription(message);\n          await this._setAnswer(answer);\n        } else if (message.type === 'candidate') {\n          if (message.ice) {\n            const candidate = new window.RTCIceCandidate(message.ice);\n\n            if (this._hasReceivedSdp) {\n              this._addIceCandidate(candidate);\n            } else {\n              this._candidates.push(candidate);\n            }\n          }\n        }\n      } catch (error) {\n        this.disconnect();\n\n        this._callbacks.disconnect({\n          reason: 'SIGNALING-ERROR',\n          error: error\n        });\n      }\n    };\n  }\n\n  _createPeerConnection() {\n    const pcConfig = {\n      iceServers: this.options.iceServers\n    };\n    const pc = new window.RTCPeerConnection(pcConfig);\n\n    if ('ontrack' in pc) {\n      pc.ontrack = event => {\n        const stream = event.streams[0];\n        if (!stream) return;\n        if (stream.id === 'default') return;\n        this.remoteStreamId = stream.id;\n        event.stream = stream;\n\n        this._callbacks.addstream(event);\n      };\n    } else {\n      pc.onaddstream = event => {\n        const stream = event.stream;\n\n        if (this.remoteStreamId && stream.id !== this.remoteStreamId || this.remoteStreamId === null) {\n          this.remoteStreamId = stream.id;\n\n          this._callbacks.addstream(event);\n        }\n      };\n\n      pc.onremovestream = event => {\n        if (this.remoteStreamId && event.stream.id === this.remoteStreamId) {\n          this.remoteStreamId = null;\n\n          this._callbacks.removestream(event);\n        }\n      };\n    }\n\n    pc.onicecandidate = event => {\n      if (event.candidate) {\n        this._sendIceCandidate(event.candidate);\n      }\n    };\n\n    pc.oniceconnectionstatechange = () => {\n      switch (pc.iceConnectionState) {\n        case 'closed':\n        case 'failed':\n        case 'disconnected':\n          break;\n      }\n    };\n\n    pc.onnegotiationneeded = async () => {\n      try {\n        const offer = await pc.createOffer({\n          offerToReceiveAudio: this.options.audio,\n          offerToReceiveVideo: this.options.video\n        });\n        await pc.setLocalDescription(offer);\n\n        this._sendSdp(pc.localDescription);\n      } catch (error) {\n        this.disconnect();\n\n        this._callbacks.disconnect({\n          reason: 'NEGOTIATION-ERROR',\n          error: error\n        });\n      }\n    }; // Add local stream to pc.\n\n\n    if (this.stream) {\n      if (typeof pc.addStream === 'undefined') {\n        this.stream.getTracks().forEach(track => {\n          pc.addTrack(track, this.stream);\n        });\n      } else {\n        pc.addStream(this.stream);\n      }\n    }\n\n    if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isUnifiedPlan\"])(pc)) {\n      pc.addTransceiver('video', {\n        direction: 'recvonly'\n      });\n      pc.addTransceiver('audio', {\n        direction: 'recvonly'\n      });\n    }\n\n    return pc;\n  }\n\n  async _createAnswer() {\n    if (!this._pc) {\n      return;\n    }\n\n    try {\n      let answer = await this._pc.createAnswer();\n      await this._pc.setLocalDescription(answer);\n\n      this._sendSdp(this._pc.localDescription);\n    } catch (error) {\n      this.disconnect();\n\n      this._callbacks.disconnect({\n        reason: 'CREATE-ANSWER-ERROR',\n        error: error\n      });\n    }\n  }\n\n  async _setAnswer(sessionDescription) {\n    await this._pc.setRemoteDescription(sessionDescription);\n\n    this._drainCandidate();\n  }\n\n  async _setOffer(sessionDescription) {\n    this._pc = this._createPeerConnection();\n\n    this._pc.onnegotiationneeded = () => {};\n\n    try {\n      await this._pc.setRemoteDescription(sessionDescription);\n      await this._createAnswer();\n    } catch (error) {\n      this.disconnect();\n\n      this._callbacks.disconnect({\n        reason: 'SET-OFFER-ERROR',\n        error: error\n      });\n    }\n  }\n\n  _addIceCandidate(candidate) {\n    this._pc.addIceCandidate(candidate);\n  }\n\n  _drainCandidate() {\n    this._hasReceivedSdp = true;\n\n    this._candidates.forEach(candidate => {\n      this._addIceCandidate(candidate);\n    });\n\n    this._candidates = [];\n  }\n\n  _sendIceCandidate(candidate) {\n    const message = {\n      type: 'candidate',\n      ice: candidate\n    };\n\n    this._sendWs(message);\n  }\n\n  _sendSdp(sessionDescription) {\n    this._sendWs(sessionDescription);\n  }\n\n  _sendWs(message) {\n    if (this._ws) {\n      this._ws.send(JSON.stringify(message));\n    }\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Connection);\n\n//# sourceURL=webpack://Ayame/./connection/index.js?")},"./utils.js":
/*!******************!*\
  !*** ./utils.js ***!
  \******************/
/*! exports provided: randomString, isUnifiedPlan */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"randomString\", function() { return randomString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isUnifiedPlan\", function() { return isUnifiedPlan; });\nfunction randomString(strLength) {\n  var result = [];\n  var charSet = '0123456789';\n\n  while (strLength--) {\n    result.push(charSet.charAt(Math.floor(Math.random() * charSet.length)));\n  }\n\n  return result.join('');\n}\nfunction isUnifiedPlan(peer) {\n  const config = peer.getConfiguration();\n  return 'addTransceiver' in peer && (!('sdpSemantics' in config) || config.sdpSemantics === 'unified-plan');\n}\n\n//# sourceURL=webpack://Ayame/./utils.js?")}})});